#!/bin/bash
#note that this section is only present when you curl it in and run it.
#after that you will not see this block
touch /tmp/x && tee –i /tmp/x > /dev/null && echo "#!/bin/bash"|cat - /tmp/x > /tmp/out && mv /tmp/out /tmp/x && $([ -d /src/deployment ] || mkdir -p /src/deployment) && touch /src/deployment/gitploy && cat - /tmp/x > /src/deployment/gitploy && $([ -x /usr/sbin/gitploy ] || ln -s /src/deployment/gitploy /usr/sbin/gitploy) && chmod a=r+w+x /usr/sbin/gitploy && gitploy install;
#===============================================================================
#          FILE: gitploy
#
#   DESCRIPTION: Repo integration and deployment
#
#          BUGS: https://github.com/jeremyBass/gitploy/issues
#
#     COPYRIGHT: (c) 2015 by the Pleasures, see AUTHORS.rst for more
#                details.
#
#       LICENSE: Apache 2.0
#  ORGANIZATION: pleasures llc
#       CREATED: 1/1/2014
#===============================================================================
set -o nounset                              # Treat unset variables as an error
__ScriptVersion="0.4.6"
__ScriptName="gitploy"

#===  FUNCTION  ================================================================
#         NAME:  usage
#  DESCRIPTION:  Display usage information.
#===============================================================================
SCRIPT=${0##*/}
IFS=$''
usage() {
    cat << END
  version : ${__ScriptVersion}
  Usage :  ${__ScriptName} [<command>] [options]

  Actions:
    init           => Initialize .gitploy/ folder
    ls/list        => List installed modules
    rm/remove      => Remove specified module
    up/update      => Update specified module
    re/refresh     => Refresh files of specified module
    info           => Show information about a specific module
    files          => List deployed files of specified module
    proxy          => Run git command into specified module
    install        => Install gitploy
    update_gitploy => This will update gitploy it's self


  Command Examples:
    ${__ScriptName} <module> <repository> //(note this installs the repo)
    ${__ScriptName} init
    ${__ScriptName} ls
    ${__ScriptName} rm <module>
    ${__ScriptName} up <module>
    ${__ScriptName} re <module>
    ${__ScriptName} info <module>
    ${__ScriptName} files <module>
    ${__ScriptName} proxy <module> <git_args>
    ${__ScriptName} install
    ${__ScriptName} update_gitploy

  Options:
  -v   Show gitploy version
  -h   Show this help
  -d   (Dry run) Dry run mode (show what would be done)
  -i   (Include) Only deploys items that match the filters
  -c   (Callback) Point to an action file with in the repo.  If none set,
                  default is installer
  -e   (Exclude) Filters out listed items.  May use regex syntax
  -b   (Branch) Specify a repository branch (only for add command)
  -t   (Tag) Specify a repository tag (only for add and update command
             also overpowers -b )
  -z   (Reset) Reset a repo on operation.  Really only applies to updates.
               You will move from tag to branch at head release
  -f   (Folder root) Set the folder in the repo to root the tracking from.
           (** NOTE:: setting to false will clear the root used adn return the
                      repo back to a normal checkout ** )
  -r   (Reqursive) Move through the modules tracked reqursively
  -u   (Unattended) This flag will accept all promots.
  -q   (Quite) If you must hide the verbose output, this flag will
               block all stdout
  -w   (Wall Broadcasting) tell anyone on the server you are about to
                           run an action
  -p   (Path installed) Where is the repo installed to from root (beta)
  -g   (user group) if set then only that user that is in that group can operate that repo


END
}
# ----------  end of usage  ----------

#-----------------------------------------------------------------------
#  Defaults
#-----------------------------------------------------------------------
#fill out
# Case-insensitive for regex matching
shopt -s nocasematch

#- Some truth values
GD_TRUE=1
GD_FALSE=0

#- run constants
GD_FOLDER=".gitploy"
GD_ROOT=$(pwd -P)
GD_DIR="$GD_ROOT/$GD_FOLDER"
GD_REPO=""
_INSTALL_PATH=""

#- Set private repo vars
GD_GROUP=""

#- git repo api settings
GD_API_URL="https://api.github.com"

#- run defaults
GD_UNATTENDED=$GD_FALSE
GD_RECURSIVE=$GD_FALSE
GD_REFRESH=$GD_FALSE
GD_RESET=$GD_FALSE
GD_QUIET=$GD_FALSE
GD_WALL=$GD_TRUE

#- running as defaults
DRY_RUN=$GD_FALSE
ACTION=""

#- data holders
declare -A _TMP_INC_FLT=()
declare -A _CALLBACKS=()

#- options defaults
INCLUDES=""
EXCLUDES=""
GITEXCLUDES="\
readme.*
README.*
about.*
license.*
copyright.*
changelog.*
credit.*
faq.*
\.travis.*
\.git.*
modman
composer\.json"

#- repo settings
_OWNER="washingtonstateuniversity"
_BRANCH="master"
_TAG=""
_ROOTFOLDER=""


cur_file=""
_PROXYING=GD_FALSE






#===  FUNCTION  ================================================================
#          NAME:  echostd
#   DESCRIPTION:  Echo stdout.  Basicly a proxy is what is done
#===============================================================================
echostd() {
	[ $GD_QUIET -eq $GD_FALSE ] && printf "%s\n" "$@";
}

#===  FUNCTION  ================================================================
#          NAME:  echoerr
#   DESCRIPTION:  Echo errors to stderr.
#===============================================================================
echoerr() {
	printf "ERROR: $@\n" 1>&2;
	exit 1
}

#===  FUNCTION  ================================================================
#          NAME:  echoinfo
#   DESCRIPTION:  Echo information to stdout.
#===============================================================================
echoinfo() {
	[ $GD_QUIET -eq $GD_FALSE ] && printf "INFO: %s\n" "$@";
}

#===  FUNCTION  ================================================================
#          NAME:  echowarn
#   DESCRIPTION:  Echo warning informations to stdout.
#===============================================================================
echowarn() {
	[ $GD_QUIET -eq $GD_FALSE ] && printf "WARN: %s\n" "$@";
}

#===  FUNCTION  ================================================================
#          NAME:  echodebug
#   DESCRIPTION:  Echo debug information to stdout.
#===============================================================================
echodebug() {
	if [ $GD_DEBUG -eq $GD_TRUE ]; then
		printf "DEBUG: %s\n" "$@";
	fi
}

#===  FUNCTION  ================================================================
#          NAME:  echofin
#   DESCRIPTION:  Echo a final massage unless it's both -u and -q.
#===============================================================================
echofin() {
	if [ $GD_UNATTENDED -ne $GD_TRUE ]; then
		if [ $GD_QUIET -ne $GD_TRUE ]; then
			printf "Finished: %s\n" "$@";
			exit 0
		fi
	fi
}

#-----------------------------------------------------------------------
#  Show help there is nothing but the command or action is "help"
#-----------------------------------------------------------------------
if [[ $# -eq 0 ]];then
	usage
	echoerr "You need to call more then gitploy.  Try added some options"
fi
if [[ "$1" = "help" ]];then
	usage
	exit 0
fi

#===  FUNCTION  ================================================================
#          NAME:  merge_include
#   DESCRIPTION:  Merge the INCLUDES with agrs for stuff not needed.
#===============================================================================
merge_include() {
	if [ -z "$INCLUDES" ]; then
		INCLUDES="$1"
	else
		INCLUDES="$INCLUDES\n$1"
	fi
}

#===  FUNCTION  ================================================================
#          NAME:  filter_include
#   DESCRIPTION:  checks if the items should be included.
#===============================================================================
filter_include() {
	file="$1"
	includes_file="$2"
	copy=$3
	if [ -s "$includes_file" ]; then
		copy=$GD_FALSE
		for filter in $(cat "$includes_file"); do
			src=$(echo $filter | cut -d: -f1)
			if [ -z "$src" ]; then
				continue
			fi
			if [[ "$file" =~ ^$src ]]; then
				copy=$GD_TRUE
				# Handle optional different target
				real=$(echo $filter | cut -d: -f2)
				if [ "$src" != "$real" ]; then
					tmp_src=$(echo $src | sed 's/^[\/]*//;s/[\/]*$//')
					tmp_src="$tmp_src/"
					tmp_src="${tmp_src//\//\\/}"
					tmp_real=$(echo $real | sed 's/^[\/]*//;s/[\/]*$//')
					tmp_real="$tmp_real/"
					tmp_real="${tmp_real//\//\\/}"
					target=$(echo $file | sed "s/$tmp_src/$tmp_real/g")
				fi
				break
			fi
		done
	fi
	_TMP_INC_FLT["copy"]=$copy
	_TMP_INC_FLT["target"]=$target
	return 0
}


#===  FUNCTION  ================================================================
#          NAME:  merge_exclude
#   DESCRIPTION:  Merge the GITEXCLUDES with agrs for github stuff not needed.
#===============================================================================
merge_exclude() {
	if [ -z "$GITEXCLUDES" ]; then
		EXCLUDES="$1"
	else
		EXCLUDES="$GITEXCLUDES\n$1"
	fi
}

#===  FUNCTION  ================================================================
#          NAME:  filter_exclude
#   DESCRIPTION:  checks if the items should be filtered out.
#===============================================================================
filter_exclude() {
	file="$1"
	excludes_file="$2"
	copy=$3
	if [ -s "$excludes_file" ] && [ $copy -eq $GD_TRUE ]; then
	  for filter in $(cat "$excludes_file"); do
		if [[ "$file" =~ ^$filter ]]; then
		  copy=$GD_FALSE
		  break
		fi
	  done
	fi
	echo $copy
}

#===  FUNCTION  ================================================================
#          NAME:  run_callback
#   DESCRIPTION:  run a callback action now that its at the end.
#===============================================================================
run_callback() {
	exit 0
}

#===  FUNCTION  ================================================================
#          NAME:  queue_callback
#   DESCRIPTION:  we are going to run a callback action at the end.
#===============================================================================
queue_callback() {
	_CALLBACKS["file"]="path/to/file"
}

#===  FUNCTION  ================================================================
#          NAME:  check_group
#   DESCRIPTION:  test if the user is in the approved group
#===============================================================================
check_group() {

	local module="$GD_REPO"
	local module_dir="$GD_DIR/$module";

	if [ -z "$GD_GROUP"  ] || [ "$GD_GROUP" = "" ]; then
		_FOE_GROUP=""
		[ -s "$module_dir/group.gitploy" ] && _FOE_GROUP=$(cat "$module_dir/group.gitploy")
		[ "$_FOE_GROUP" != "" ] && GD_GROUP=$_FOE_GROUP
		echostd "going to use group '$_FOE_GROUP'"
	fi

	if [ "$GD_GROUP" != "" ]; then
		if groups $USER | grep &>/dev/null $GD_GROUP; then
			echostd "used group '$_FOE_GROUP' for user $USER"
			return $GD_TRUE
		else
			echoerr "your not in $GD_GROUP"
		fi
	fi
	echostd "used group '$_FOE_GROUP' for user $USER"
	return $GD_TRUE

}



#===  FUNCTION  ================================================================
#         NAME:  __build_dirs
#  DESCRIPTION:  Builds for default folders needed to operate correctly.
#===============================================================================
__build_dirs() {
	[ -d $GD_DIR ] && echoerr "$SCRIPT is already initialized"
	mkdir $GD_FOLDER || echoerr "Could not create .gitploy directory"

}

#===  FUNCTION  ================================================================
#         NAME:  __symlink_exc
#  DESCRIPTION:  Builds for default folders needed to operate correctly.
#===============================================================================
__symlink_exc() {
	if [ -f /src/deployment/gitploy ]; then
		if [ -h /usr/sbin/gitploy ]; then
			echostd "gitploy was already loaded"
		else
			[ -h /usr/local/bin/gitploy ]   || ln -s /src/deployment/gitploy /usr/local/bin/gitploy
			[ -h /usr/sbin/gitploy ]        || ln -s /src/deployment/gitploy /usr/sbin/gitploy
			[ -h /etc/init.d/gitploy ]      || ln -s /src/deployment/gitploy /etc/init.d/gitploy
			chmod a=r+w+x /usr/local/bin/gitploy
		fi
	fi
}




#===  FUNCTION  ================================================================
#          NAME:  __proxy_init
#   DESCRIPTION:  in process of making executable, it may be stored in the wrong
#                 location. Copy, init with pwd args, remove old
#===============================================================================
__proxy_init(){
	#ensure the deployment bed
	[ -d /src/deployment ] || mkdir -p /src/deployment
	if [[ $PWD = "/src/deployment/" && -f /src/deployment/gitploy ]]; then
		#nothing to do
		echostd "gitploy running from in the right place and exist"
	else
		if [ -f /src/deployment/gitploy ]; then
			echostd "it was there keep moving"
			[ ${PWD} ] && [ -f "${PWD}/–i" ] && rm -f "${PWD}/–i" && echostd "cleared tee tmp"
		else
			if [ ${PWD} ]; then
				cur_file= "${PWD}/gitploy"
				if [ ${cur_file} ]; then
					cp -fL $cur_file /src/deployment/gitploy
				else
					_PROXYING=GD_TRUE
				fi
			else
				#copy it over if not stream
				_PROXYING=GD_TRUE
			fi
			if [ -f /src/deployment/gitploy ]; then
				__symlink_exc
			fi
			echostd "removing current"
			[ -f "${PWD}/–i" ] && rm -f "${PWD}/–i"
			rm -f $cur_file && exit 0 || echoerr "Failed to clean up"

		fi
		[ -f /usr/sbin/gitploy ] || echoerr "failed to proxy the init, try to run in /src/deployment"
	fi
}

#===  FUNCTION  ================================================================
#          NAME:  applyaliases
#   DESCRIPTION:  set up some git aliases to be convinent to user and gitploy
#===============================================================================
applyaliases() {

	git config --global --replace-all alias.reset-master '!f() { git reset --hard && git clean -f -x -d && git fetch upstream && git checkout master && git reset --hard upstream/master && git push origin master --force; }; f'

	git config --global --replace-all alias.up-sub '!f() { cd $1 && git checkout master && git pull && git submodule update --init --recursive; }; f'

	git config --global --replace-all alias.branch-status '!f() { remote_url=$(git config --get remote.origin.url); tag=$(<../tag.gitploy); branch=$(<../branch.gitploy); [ \"X$tag\" != \"X\" ] && local=$(git rev-list -n 1 $tag) && remote=$(git ls-remote --tags $remote_url -t $tag | awk \"{ print $1 }\"); [ \"X$tag\" == \"X\" ] && local=$(git rev-parse origin/$branch) && remote=$(git ls-remote $remote_url $branch | awk \"{ print $1 }\"); [[ \"${local}\" == \"${remote}\" ]] && echo 0 || echo 1; }; f'

	exit 1
}



#===  FUNCTION  ================================================================
#          NAME:  __update_gitploy
#   DESCRIPTION:  update the gitploy script
#===============================================================================
__update_gitploy(){
	echostd "from $__ScriptVersion";
	local now=$(date +"%Y%m%d%H%M%S")
	local update_url=https://raw.githubusercontent.com/jeremyBass/gitploy/master/gitploy?$(echo $now|md5sum)
	echostd "Updating gitploy from $update_url"
	curl "$update_url" | sudo sh -s -- install
	current_version=$(gitploy -v)
	echostd "to $current_version";
	applyaliases
	return 0
}



#===  FUNCTION  ================================================================
#          NAME:  __init_gitploy
#   DESCRIPTION:  sets up gitploy as user and system executable.
#===============================================================================
__install_gitploy(){
	__proxy_init
	__symlink_exc
	applyaliases
	return 0
}


#===  FUNCTION  ================================================================
#          NAME:  require_mods
#   DESCRIPTION:  checks that there are mods.
#===============================================================================
require_mods() {
  count=$(ls -A "$GD_DIR" | wc -l | sed 's/ //g')
  [ $count -eq 0 ] && echoerr "There is no module installed"
}


#-----------------------------------------------------------------------
#  If not installed, do so
#-----------------------------------------------------------------------
if [ "$1" = "install" ]; then
	PKG_MANAGER=$( command -v yum || command -v apt-get ) || echo "Neither yum nor apt-get found"
	$(git -v 2>&1 | grep -qi "command not found") && $PKG_MANAGER install -y git
	if [ $(gitploy -v 2>&1 | grep -qi "Version") ];then
		echoerr "gitploy seems to be already installed"
	else
		if [ -f /src/deployment/gitploy ]; then
			__install_gitploy && echostd "gitploy was installed" && exit 0
			echoerr "gitploy failed install"
		else
			echoerr "gitploy file was missing failed install"
		fi
	fi
fi


#-----------------------------------------------------------------------
#  Accept action as first argument or as add | note: add is default
#-----------------------------------------------------------------------
REGEX_ACTION="(init|list|ls|info|files|clone|add|update|up|remove|rm|proxy|re|refresh|update_gitploy)"
if [[ "$1" =~ $REGEX_ACTION ]]; then
	ACTION="$1"; shift
fi

#-----------------------------------------------------------------------
#  Handle command line arguments
#-----------------------------------------------------------------------
#fill out

# Handle options
while getopts "zhvdurqw:c:i:e:o:b:t:f:p:g" opt; do
  case $opt in

	#flag----------------------
	h)
	  usage;
	  exit 0
	  ;;
	v)
	  echostd "$0 -- Version $__ScriptVersion";
	  exit 0
	  ;;
	d) DRY_RUN=$GD_TRUE                  ;;
	u) GD_UNATTENDED=$GD_TRUE            ;;
	r) GD_RECURSIVE=$GD_TRUE             ;;
	q) GD_QUIET=$GD_TRUE                 ;;
	w) GD_WALL=$GD_FALSE                 ;;
	z) GD_RESET=$GD_TRUE                 ;;


	#callback------------------
	c) queue_callback "$OPTARG"
	  shift $((OPTIND-1)); OPTIND=1
	  ;;

	#data----------------------
	i) merge_include "$OPTARG"
	  shift $((OPTIND-1)); OPTIND=1
	  ;;
	e) merge_exclude "$OPTARG"
	  shift $((OPTIND-1)); OPTIND=1
	  ;;
	p) _INSTALL_PATH=$( echo $OPTARG | sed -e 's:^/*::' -e 's:/*$::')"/" #trim /
	  echoinfo "Installing to $_INSTALL_PATH"
	  shift $((OPTIND-1)); OPTIND=1
	  ;;

	#git options---------------
	o ) _OWNER=$OPTARG
	  shift $((OPTIND-1)); OPTIND=1
	  ;;
	b ) _BRANCH=$OPTARG
	  shift $((OPTIND-1)); OPTIND=1
	  echostd "set -b $_BRANCH"
	  ;;
	t ) _TAG=$OPTARG
	  shift $((OPTIND-1)); OPTIND=1
	  ;;
	f) _ROOTFOLDER=$OPTARG
	  shift $((OPTIND-1)); OPTIND=1
	  ;;
	g) GD_GROUP=$OPTARG
	  shift $((OPTIND-1)); OPTIND=1
	  ;;


	\?)  echo
		 echoerr "Option does not exist : $OPTARG"
		 usage
		 exit 1
		 ;;
  esac
done
shift $(($OPTIND-1))






#-----------------------------------------------------------------------
# Alert everyone there is going to be some action done
#-----------------------------------------------------------------------
#[ $GD_WALL -eq $GD_TRUE ] && wall -n "PLEASE NOTE: action ${ACTION} is being run from ${USER}, \n and you should pause what you are doing.  If you believe you need some time run command \n \$ wall \"STOP ACTION\" with in the next 10 secs" && sleep 10


#-----------------------------------------------------------------------
# Start the real process
#-----------------------------------------------------------------------
#-----------------------------------------------------------------------
# Assume if there are options, that it was not help or init that it's
# the add action.  We should be only left with that possiblity by now
#-----------------------------------------------------------------------
if [ -z $ACTION ];then
	if [[ $# -gt 0 ]];then
		ACTION="add"
	fi
fi

#-----------------------------------------------------------------------
# Initializes Dry run
#-----------------------------------------------------------------------
if [ $DRY_RUN -eq $GD_TRUE ]; then
  echoinfo "DRY RUN MODE ON"
  sleep 1
fi


#-----------------------------------------------------------------------
# Initializes UNATTENDED use
#-----------------------------------------------------------------------
if [ $GD_UNATTENDED -eq $GD_TRUE ]; then
  echoinfo "UNATTENDED MODE ON"
  sleep 1
fi

#-----------------------------------------------------------------------
# Initializes RECURSIVE use
#-----------------------------------------------------------------------
if [ $GD_RECURSIVE -eq $GD_TRUE ]; then
  echoinfo "RECURSIVE MODE ON"
  sleep 1
fi

#===  FUNCTION  ================================================================
#          NAME:  default_folders
#   DESCRIPTION:  create all default files just incase
#===============================================================================
default_folders(){
	local module_dir="$GD_DIR/$GD_REPO"
	[ -f "$module_dir/install_root.gitploy" ] || > "$module_dir/install_root.gitploy"
	[ -f "$module_dir/update.gitploy" ] || > "$module_dir/update.gitploy"
	[ -f "$module_dir/delete.gitploy" ] || > "$module_dir/delete.gitploy"
	[ -f "$module_dir/deployed.gitploy" ] || > "$module_dir/deployed.gitploy"
	[ -f "$module_dir/diff.gitploy" ] || > "$module_dir/diff.gitploy"
	[ -f "$module_dir/includes.gitploy" ] || > "$module_dir/includes.gitploy"
	[ -f "$module_dir/excludes.gitploy" ] || > "$module_dir/excludes.gitploy"
	[ -f "$module_dir/tag.gitploy" ] || > "$module_dir/tag.gitploy"
	[ -f "$module_dir/branch.gitploy" ] || > "$module_dir/branch.gitploy"
	[ -f "$module_dir/repository.gitploy" ] || > "$module_dir/repository.gitploy"
	[ -f "$module_dir/rooted.gitploy" ] || > "$module_dir/rooted.gitploy"
	[ -f "$module_dir/group.gitploy" ] || > "$module_dir/group.gitploy"
}

#===  FUNCTION  ================================================================
#          NAME:  resolve_install_root
#   DESCRIPTION:  build the path the repo is install to rooted from gitploy init
#===============================================================================
resolve_install_root(){
	local module_dir="$GD_DIR/$GD_REPO"
	local install="$module_dir/install_root.gitploy"
	> "$module_dir/install_root.gitploy"

	#at this point we are reading a user input
	if ! [ -z "$_INSTALL_PATH" ]; then
		_INSTALL_PATH=$( echo $_INSTALL_PATH | sed -e 's:^/*::' -e 's:/*$::')"/"
		echo "$_INSTALL_PATH" > $install #save value
		return 0
	fi

	#there was no user input so we will read from file
	local target_install=""

	[ -s "$install" ] && target_install=$(cat "$install")
	if ! [ -z "$target_install" ]; then
		_INSTALL_PATH=$( echo $target_install | sed -e 's:^/*::' -e 's:/*$::')"/"
		return 0
	fi
	_INSTALL_PATH=""
	return 0
}

#===  FUNCTION  ================================================================
#          NAME:  mod_git_reset
#   DESCRIPTION:  reset a repo to the head.  It may be a tag release but we will
#                 will now pull to branch (master or defined) and at head
#===============================================================================
mod_git_reset(){
	local module_dir="$GD_DIR/$GD_REPO"
	if [ $DRY_RUN -eq $GD_TRUE ]; then
		echostd "'$GD_REPO' module would be cleaned and reset when not in dryrun"
		git clean -n
		return 0
	fi
	echostd "'$GD_REPO' module is being cleaned and reset"
	> "$module_dir/tag.gitploy"
	git reset --hard
	git clean --force
	return 0
}

#===  FUNCTION  ================================================================
#          NAME:  sparse_checkout
#   DESCRIPTION:  get a sub-tree of a repo and track that only
#===============================================================================
sparse_checkout(){
	local module_dir="$GD_DIR/$GD_REPO"
	local source_sparse_dir="$module_dir/source/.git/info"
	local sparse_file="$source_sparse_dir/sparse-checkout"

	git config core.sparsecheckout true

	> "$sparse_file"

	IFS=',' read -a folders <<< "$_ROOTFOLDER"
	for folder in "${folders[@]}"
	do
		echo $folder >> "$source_sparse_dir/sparse-checkout"
		echostd "a subtree using folder '$folder'"
	done
	git read-tree -mu HEAD
	echostd "'$GD_REPO' is using a subtree starting at '$_ROOTFOLDER'"

	#if the above don't work then
	#if [[ $string == *,* ]]
	#then
	#	IFS=',' read -a folders <<< "$_ROOTFOLDER"
	#	for folder in "${folders[@]}"
	#	do
	#		echo $folder >> .git/info/sparse-checkout
	#	done
	#else
	#	echo $_ROOTFOLDER >> .git/info/sparse-checkout
	#fi
	echostd "'$GD_REPO' is rooted at $_ROOTFOLDER"
	return 0
}

#===  FUNCTION  ================================================================
#          NAME:  sparse_to_full
#   DESCRIPTION:  remove a sub-tree of a repo and track everything again
#===============================================================================
sparse_to_full(){
	local module_dir="$GD_DIR/$GD_REPO"
	local source_dir="$module_dir/source"
	local _dirty=""

	[ -s "$source_dir/.git/info/sparse-checkout" ] && _drity=$(cat "$source_dir/.git/info/sparse-checkout")

	if [ -z "$_drity" ]; then

		echo "*" > "$module_dir/.git/info/sparse-checkout"
		git read-tree -mu HEAD
		mod_git_reset

		git config core.sparsecheckout false

	fi

	return 0
}




#===  FUNCTION  ================================================================
#          NAME:  mod_set_latest_tag
#   DESCRIPTION:  Find out what the last tagged release is for the repo and
#                 reassgin it to the global var $_TAG
#===============================================================================
mod_set_latest_tag(){
	if [ "$_TAG" == "latest" ]; then
		git fetch --tags
		latestTag=$(git describe --tags `git rev-list --tags --max-count=1`)
		echostd "found the latest tag of '$latestTag'"
		_TAG=$latestTag
	fi
	return 0
}


#===  FUNCTION  ================================================================
#          NAME:  require_mod_dir
#   DESCRIPTION:  Checks if module dir exists or quit.
#===============================================================================
require_mod_dir(){
	[ -d "$GD_DIR/$GD_REPO" ] || echoerr "Module '$GD_REPO' does not exist"
	return 0
}

#===  FUNCTION  ================================================================
#          NAME:  check_for_change
#   DESCRIPTION:  Checks if the repo has any changes it needs from the remote.
#===============================================================================
check_for_change(){
	git branch-status
	return 0
}



#===  FUNCTION  ================================================================
#          NAME:  rm_mod_dir
#   DESCRIPTION:  Removes the module as needed safely.
#===============================================================================
rm_mod_dir() {
	local module_dir="$GD_DIR/$GD_REPO"
	if [ -n "$GD_REPO" ] && [ -d "$module_dir" ]; then
		rm -rf "$module_dir" 2>/dev/null
	fi

	return 0
}

#===  FUNCTION  ================================================================
#          NAME:  rm_mod_dir
#   DESCRIPTION:  Deletes deployed files of specified module. Could be not safe
#===============================================================================
rm_mod_files() {
	IFS=$'\n'
	local module_dir="$GD_DIR/$GD_REPO"
	local deployed_file="$module_dir/deployed.gitploy"

	[ -s "$module_dir/rooted.gitploy" ] && _ROOTFOLDER=$(cat "$module_dir/rooted.gitploy")

	[ $DRY_RUN -eq $GD_TRUE ] && echoinfo "Would be remove files-" || echoinfo "Removing files-"

	echostd "rooted at: $_ROOTFOLDER"
	echostd "installed at: $_INSTALL_PATH"

	for line in $(cat "$deployed_file" 2>/dev/null); do

		local tar_file=$line

		if ! [ -z "$_ROOTFOLDER" ];
		then
			IFS=',' read -a folders <<< "$_ROOTFOLDER"
			for folder in "${folders[@]}"
			do
				tar_file=${tar_file#$folder}
			done
		fi

		local file=$GD_ROOT/$_INSTALL_PATH${tar_file#$GD_ROOT}

		if ! [ -z "$file" ] && [ -f "$file" ] && [ "x$file" != "x$GD_ROOT/" ]; then
			echostd "-- $file"
			# Remove deployed file and empty dirs
			if [ $DRY_RUN -eq $GD_FALSE ]; then
				rm "$file" 2>/dev/null
				prev_dir=""
				dir=$(dirname "$file")
				while [ "$dir" != "$prev_dir" ]; do
					prev_dir=$dir
					test_dir="$dir"
					if ! [ "$(ls -A $test_dir)" ]; then
						rmdir $test_dir
					fi
					dir=${dir%/*}
				done
			fi
		fi
	done
	return 0
}

#===  FUNCTION  ================================================================
#          NAME:  rm_mod
#   DESCRIPTION:  Removes specified module
#===============================================================================
rm_mod() {
	IFS=$'\n'
	local module_dir="$GD_DIR/$GD_REPO"

	require_mod_dir
	if [ $DRY_RUN -eq $GD_FALSE ]; then
		if [ $GD_UNATTENDED -eq $GD_FALSE ]; then
			read -p "Are you sure you want to remove '$GD_REPO' module? (y/n): " confirm
			[ "$confirm" != "y" ] && [ "$confirm" != "" ] && echo "Aborting..." && return 0
		fi
	fi

	echostd "Removing '$GD_REPO' module..."
	sleep 1

	rm_mod_files || return 1

	[ $DRY_RUN -eq $GD_TRUE ] && return 0
	rm_mod_dir

	return $?
}

#===  FUNCTION  ================================================================
#          NAME:  deploy_file
#   DESCRIPTION:  Copies specified file to root directory
#===============================================================================
deploy_file() {
	local file=$1
	local tar_file="$file"
	local module_dir="$GD_DIR/$GD_REPO"

	[ -s "$module_dir/rooted.gitploy" ] && _ROOTFOLDER=$(cat "$module_dir/rooted.gitploy")
	#echo "starting from /$_ROOTFOLDER"
	if ! [ -z "$_ROOTFOLDER" ];
	then
		IFS=',' read -a folders <<< "$_ROOTFOLDER"
		for folder in "${folders[@]}"
		do
			tar_file=${file#$folder}
		done
	fi

	if [ $DRY_RUN -eq $GD_FALSE ]; then
		echostd "++ $_INSTALL_PATH$tar_file"
		mkdir -p $(dirname "$GD_ROOT/$_INSTALL_PATH$tar_file") && cp "$file" "$GD_ROOT/$_INSTALL_PATH$tar_file"
	fi
}


#===  FUNCTION  ================================================================
#          NAME:  mv_files
#   DESCRIPTION:  Synchronizes files from mod dir to root dir, then stores
#                 deployed files for easy removal later
#===============================================================================
mv_files() {
	local module_dir="$GD_DIR/$GD_REPO"
	local source_dir="$module_dir/source"
	local includes_file="$module_dir/includes.gitploy"
	local excludes_file="$module_dir/excludes.gitploy"
	local modman_file="$source_dir/modman"
	local deployed_file="$module_dir/deployed.gitploy"
	local install="$module_dir/install_root.gitploy"

	> "$deployed_file" #creat empty file
	cd "$source_dir" || return 1

	IFS=$'\n'; set -f; files=($(find . -type f -not -iwholename '*.git*' | sed 's/^\.\///'))
	for file in "${files[@]}"; do
		# Copy file by default
		copy=$GD_TRUE
		target="$file"

		# Include filter
		filter_include "$file" "$includes_file" $copy
		copy=${_TMP_INC_FLT["copy"]}
		target=${_TMP_INC_FLT["target"]}

		# Exclude filter
		copy=$(filter_exclude "$file" "$excludes_file" $copy)

		#start the process
		if [ $copy -eq $GD_TRUE ]; then
			# Handle modman file
			if [ -s "$modman_file" ]; then
				IFS=$'\n'
				for line in $(cat "$modman_file"); do
					if [ -z "$line" ] || [[ $line =~ ^# ]] || [[ $line =~ ^@ ]]; then
						continue
					fi
					IFS=$' \t'
					line="${line/\*/}" # remove * char
					set -- $line       # set $1 and $2
					if [[ "$file" =~ ^$1 ]]; then
						# Remove trailing slashes and escape paths for sed
						src=$(echo $1 | sed 's/^[\/]*//;s/[\/]*$//')
						dest=$(echo $2 | sed 's/^[\/]*//;s/[\/]*$//')
						src="${src//\//\\/}"
						dest="${dest//\//\\/}"
						target=$(echo $file | sed "s/$src/$dest/g")
						deploy_file "$file"
						echo "$file" >> "$deployed_file"
					fi
				done
			else
				deploy_file "$file"
				echo "$file" >> "$deployed_file"
			fi
		fi

	done
	return 0
}


#===  FUNCTION  ================================================================
#          NAME:  build_deploy_file
#   DESCRIPTION:  sets up the file for deployment
#===============================================================================
build_deploy_file() {
	IFS=$'\n'

	local module_dir="$GD_DIR/$GD_REPO"
	local source_dir="$module_dir/source"
	local includes_file="$module_dir/includes.gitploy"
	local excludes_file="$module_dir/excludes.gitploy"
	local modman_file="$source_dir/modman"
	local deployed_file="$module_dir/deployed.gitploy"

	echostd "Building '$GD_REPO' deployment"
	cd "$source_dir"

	for file in $(find . -type f -not -iwholename '*.git*' | sed 's/^\.\///'); do
		# Copy file by default
		copy=$GD_TRUE
		target="$file"

		# Include filter
		filter_include "$file" "$includes_file" $copy
		copy=${_TMP_INC_FLT["copy"]}
		target=${_TMP_INC_FLT["target"]}

		# Exclude filter
		copy=$(filter_exclude "$file" "$excludes_file" $copy)

		if [ $copy -eq $GD_TRUE ]; then
			# Handle modman file
			if [ -s "$modman_file" ]; then
				IFS=$'\n'
				for line in $(cat "$modman_file"); do
					if [ -z "$line" ] || [[ $line =~ ^# ]] || [[ $line =~ ^@ ]]; then
						continue
					fi
					IFS=$' \t'
					line="${line/\*/}" # remove * char
					set -- $line       # set $1 and $2
					if [[ "$file" =~ ^$1 ]]; then
						# Remove trailing slashes and escape paths for sed
						src=$(echo $1 | sed 's/^[\/]*//;s/[\/]*$//')
						dest=$(echo $2 | sed 's/^[\/]*//;s/[\/]*$//')
						src="${src//\//\\/}"
						dest="${dest//\//\\/}"
						target=$(echo $file | sed "s/$src/$dest/g")
						echo "$target" >> "$deployed_file"
					fi
				done
			else
				echo "$target" >> "$deployed_file"
			fi
		fi
	done
	return 0
}


#===  FUNCTION  ================================================================
#          NAME:  update_mod
#   DESCRIPTION:  Updates a module
#===============================================================================
update_mod() {
	default_folders
	IFS=$'\n'
	local module="$GD_REPO"
	local module_dir="$GD_DIR/$module"
	local source_dir="$module_dir/source"
	local _ROOTFOLDER=""
	[ -s "$module_dir/rooted.gitploy" ] && _ROOTFOLDER=$(cat "$module_dir/rooted.gitploy")

	require_mod_dir

	if [ $GD_REFRESH = $GD_TRUE ]; then
		echoinfo "Refreshing '$module' module..."
		if [ -s "$module_dir/tag.gitploy" ]; then
			local old_tag=$(cat "$module_dir/tag.gitploy")
		else
			[ -s "$module_dir/branch.gitploy" ] && _BRANCH=$(cat "$module_dir/branch.gitploy")
		fi
		> "$module_dir/deployed.gitploy"
		build_deploy_file

		# update update.gitploy files
		IFS=$'\n'
		for line in $(cat "$module_dir/deployed.gitploy" 2>/dev/null); do
			if ! [ -z "$line" ]; then
				local re_file=$line

				if ! [ -z "$_ROOTFOLDER" ];
				then
					IFS=',' read -a folders <<< "$_ROOTFOLDER"
					for folder in "${folders[@]}"
					do
						re_file=${re_file#$folder}
					done
				fi
				# copy the file
				if [ $DRY_RUN -eq $GD_FALSE ]; then
					mkdir -p $(dirname "$GD_ROOT/$_INSTALL_PATH$re_file") && cp "$line" "$GD_ROOT/$_INSTALL_PATH$re_file"
					echostd "Refreshing: $re_file"
				fi
			fi
		done
		return 0
	else
		echoinfo "Updating '$module' module..."
		> "$module_dir/update.gitploy"
		> "$module_dir/delete.gitploy"
		> "$module_dir/deployed.gitploy"
		> "$module_dir/diff.gitploy"



		cd "$source_dir"

		[ $(git branch-status) -eq $GD_FALSE ] && echostd "No changes found commit Heads matched" && return 0

		local tagcheck=$(git fetch --tags)
		local tagupdate=$(git fetch)

		local old_commit=$(git rev-parse HEAD)

		[ "x$_ROOTFOLDER" == "xfalse" ] && sparse_to_full


		# If module was fetched with a specific tag
		if [ -s "$module_dir/tag.gitploy" ]; then
			if [ -z "$_TAG" ]; then
				if [ $GD_RESET -eq $GD_FALSE ]; then
					local repo_tag=$(cat "$module_dir/tag.gitploy")
					echostd "'$module' module was fetched from tag '$repo_tag' and thus cannot be updated without -t option"
					return 1
				else
					mod_git_reset
					update_mod
					return 0
				fi
			fi

			mod_set_latest_tag

			if [ -z $(git tag -l "$_TAG") ]; then
				echostd "Tag '$_TAG' does not exist"
				return 1
			fi
			if ! git checkout --quiet "$_TAG"; then
				echostd "An error occurred while fetching tag '$_TAG'"
				return 1
			fi
			local new_commit=$(git rev-parse HEAD)
			local old_tag=$(cat "$module_dir/tag.gitploy")
			echostd "Switching from tag $old_tag to $_TAG"
			if [ $DRY_RUN -eq $GD_FALSE ]; then
				echo "$_TAG" > "$module_dir/tag.gitploy"
				git diff --stat --name-only "$old_tag" "$_TAG" --diff-filter=D > "$module_dir/delete.gitploy" 2> /dev/null
				git diff --stat --name-only "$old_tag" "$_TAG" --diff-filter=ACMR > "$module_dir/update.gitploy" 2> /dev/null
			fi
		else

			if [ -z "$_BRANCH"  ] || [ "$_BRANCH" = "master" ]; then
				_FOE_BRANCH="master"
				[ -s "$module_dir/branch.gitploy" ] && _FOE_BRANCH=$(cat "$module_dir/branch.gitploy")
				[ "$_FOE_BRANCH" != "master" ] && _BRANCH=$_FOE_BRANCH
				echostd "using non master branch '$_FOE_BRANCH'"
			fi

			echostd "Update to branch '$_BRANCH'"
			git pull --quiet origin "$_BRANCH" && git submodule --quiet update --init --recursive || return 1
			local new_commit=$(git rev-parse HEAD)
			if [ $DRY_RUN -eq $GD_FALSE ]; then
				git diff --stat --name-only "$old_commit" "$new_commit" --diff-filter=D > "$module_dir/delete.gitploy" 2> /dev/null
				git diff --stat --name-only "$old_commit" "$new_commit" --diff-filter=ACMR > "$module_dir/update.gitploy" 2> /dev/null
			fi
		fi

		local count=$(git diff --shortstat "$old_commit" "$new_commit" | cut -d" " -f2)
		[ $DRY_RUN -eq $GD_TRUE ] && git checkout --quiet "$old_commit"
		[ "$count" = "" ] && echostd "No changes found" && return 0


		if [ $DRY_RUN -eq $GD_TRUE ]; then
			echoinfo "Would modify:"
			git --no-pager diff --name-only "$old_commit" "$new_commit" --diff-filter=ACMR
			echoinfo "Would delete:"
			git --no-pager diff --name-only "$old_commit" "$new_commit" --diff-filter=D
			echostd "$count file(s) changed"
			return 0
		fi
		# update update.gitploy files
		IFS=$'\n'
		for line in $(cat "$module_dir/update.gitploy" 2>/dev/null); do
			if ! [ -z "$line" ]; then

				local up_file=$line

				if ! [ -z "$_ROOTFOLDER" ];
				then
					IFS=',' read -a folders <<< "$_ROOTFOLDER"
					for folder in "${folders[@]}"
					do
						up_file=${up_file#$folder}
					done
				fi

				# copy the file
				if [ $DRY_RUN -eq $GD_FALSE ]; then
					mkdir -p $(dirname "$GD_ROOT/$_INSTALL_PATH$up_file") && cp "$line" "$GD_ROOT/$_INSTALL_PATH$up_file"
					echostd "++: $_INSTALL_PATH$up_file"
				fi
			fi
		done

		# delete delete.gitploy files
		IFS=$'\n'
		for line in $(cat "$module_dir/delete.gitploy" 2>/dev/null); do

			local del_file=$line

			if ! [ -z "$_ROOTFOLDER" ];
			then
				IFS=',' read -a folders <<< "$_ROOTFOLDER"
				for folder in "${folders[@]}"
				do
					del_file=${del_file#$folder}
				done
			fi

			if ! [ -z "$del_file" ] && [ -f "$GD_ROOT/$del_file" ]; then
				# delete the file
				if [ $DRY_RUN -eq $GD_FALSE ]; then
					rm "$GD_ROOT/$_INSTALL_PATH$del_file" 2>/dev/null
					echostd "--: $_INSTALL_PATH$del_file"
				fi
			fi
		done

		# update the deployed.gitploy file
		if build_deploy_file;
		then
			return 0
		else
			return 1
		fi

	fi
}

#===  FUNCTION  ================================================================
#          NAME:  mod_info
#   DESCRIPTION:  echo out file info.
#===============================================================================
mod_info() {
	local module="$GD_REPO"
	local module_dir="$GD_DIR/$module"

	require_mod_dir

	echostd "Information about '$module' module:"
	if [ -s "$module_dir/repository.gitploy" ]; then
		local repo=$(cat "$module_dir/repository.gitploy")
		echostd "Repository: $repo"
	fi

	if [ -s "$module_dir/tag.gitploy" ]; then
		local current_tag=$(cat "$module_dir/tag.gitploy")
		echostd "Tag: $current_tag"
	else
		local current_branch="master"
		[ -s "$module_dir/branch.gitploy" ] && current_branch=$(cat "$module_dir/branch.gitploy")
		echostd "Branch: $current_branch"
	fi
	return 0
}





#===  FUNCTION  ================================================================
#          NAME:  mod_info_inline
#   DESCRIPTION:  print out file info.
#===============================================================================
mod_info_inline(){
	local module="$GD_REPO"
	local module_dir="$GD_DIR/$module"
	local info=""
	local url=""

	require_mod_dir

	if [ -s "$module_dir/tag.gitploy" ]; then
		local current_tag=$(cat "$module_dir/tag.gitploy")
		info="$info tag: $current_tag"
	else
		local current_branch="master"
		[ -s "$module_dir/branch.gitploy" ] && current_branch=$(cat "$module_dir/branch.gitploy")
		info="$info branch: $current_branch"
	fi

	if [ -s "$module_dir/rooted.gitploy" ]; then
		local rooted=$(cat "$module_dir/rooted.gitploy")
		info="$info  rooted from: $rooted"
	fi

	if [ -s "$module_dir/install_root.gitploy" ]; then
		local install_root=$(cat "$module_dir/install_root.gitploy")
		info="$info  install at: $install_root"
	fi

	if [ -s "$module_dir/repository.gitploy" ]; then
		local repo=$(cat "$module_dir/repository.gitploy")
		url="$repo"
	fi

	printf "$(tput bold)$module$(tput sgr0) ($info ) \n ->> $url\n\n" "$module"
	return 0
}


#===  FUNCTION  ================================================================
#          NAME:  create_module
#   DESCRIPTION:  Creates module dir, clones git repo and optionally stores
#                 include/exclude filters.
#===============================================================================
create_module() {
	default_folders
	local repo="$1"
	local module="$GD_REPO"
	local module_dir="$GD_DIR/$module"; #shift 2
	local source_dir="$module_dir/source"
	local exclude_cache="$module_dir/excludes.gitploy"
	local include_cache="$module_dir/includes.gitploy"

	[ -d "$GD_DIR" ] || mkdir -p "$GD_DIR"
	cd "$GD_DIR"



	echoinfo "Cloning $repo..."
	if ! git clone --depth=1 --quiet -- "$repo" "$source_dir"; then
		rm_mod_dir
		echoerr "An error occurred while cloning repository when running 'git clone --depth=1 --quiet -- $repo $source_dir'"
	fi

	echo "$repo" > "$module_dir/repository.gitploy"

	cd "$source_dir"

	# Ignore chmod changes in future
	git config core.filemode false

	if [ -n "$_TAG" ]; then
		mod_set_latest_tag
		if [ -z $(git tag -l "$_TAG") ]; then
			rm_mod_dir
			echoerr "Tag '$_TAG' does not exist"
		fi
		if ! git checkout -f --quiet "$_TAG"; then
			rm_mod_dir
			echoerr "An error occurred while fetching tag $_TAG"
		fi
		echo "$_TAG" > "$module_dir/tag.gitploy"
	elif ! git checkout -f --quiet "$_BRANCH"; then
		rm_mod_dir
		echoerr "An error occurred while fetching branch $_BRANCH"
	fi

	echo "$_BRANCH" > "$module_dir/branch.gitploy"
	echo "$GD_GROUP" > "$module_dir/group.gitploy"
	echo "$_ROOTFOLDER" > "$module_dir/rooted.gitploy"
	echo "$_INSTALL_PATH" > "$module_dir/install_root.gitploy"
	[ -z "$_ROOTFOLDER" ] || sparse_checkout

	echostd "Fetching submodules..."
	if ! git submodule --quiet update --init --recursive; then
		rm_mod_dir
		echoerr "An error occurred while cloning submodules of $repo"
	fi

	> "$module_dir/deployed.gitploy"
	build_deploy_file

	# Save includes filter if not empty
	[ -z "$INCLUDES" ] || echo -e "$INCLUDES" > "$include_cache"

	# Save excludes filter if not empty
	[ -z "$EXCLUDES" ] || echo -e "$EXCLUDES" > "$exclude_cache"

	return 0
}

#-----------------------------------------------------------------------
#  Handle action
#-----------------------------------------------------------------------
#pre actions that route to another action
case "$ACTION" in
  refresh|re)
	echostd "Refreshing the tracked repo"
	GD_REFRESH=$GD_TRUE
	ACTION=update
	;;

esac

case "$ACTION" in

  list|ls)
	# List all installed modules
	count=$(ls -A "$GD_DIR" | wc -l | sed 's/ //g')
	IFS=$'\n'
	for module in $(ls -1 "$GD_DIR"); do
		[ -d "$GD_DIR/$module" ] || continue;
		GD_REPO=$module
		resolve_install_root
		mod_info_inline
	done
	echostd "$count module(s) found"
	exit 0
	;;

  clone|add)
	# Install new repo
	echostd "Starting repo clone"
	GD_REPO="$1"; shift

	[ -z "$GD_REPO" ] && echoerr "No repo specified"
	repo_dir="$GD_DIR/$GD_REPO"
	[ -d "$GD_DIR" ] || mkdir -p "$GD_DIR"

	[[ "$GD_REPO" =~ [^a-z0-9_-]+ ]] &&
		echoerr "You cannot add a repo containingmore then [^a-zA-Z0-9_-]+ pattern\nModule specified: $GD_REPO"

	[ -d "$repo_dir" ] && echoerr "A module with this name already exists"
	[ -d "$repo_dir" ] || mkdir -p "$repo_dir"

	resolve_install_root

	success=$GD_TRUE
	repo="$1"; shift

	create_module "$repo" || success=$GD_FALSE

	cd "$GD_DIR"

	if [ $success -eq $GD_TRUE ]; then
		if require_mod_dir &&
			mv_files;
			then
			[ $DRY_RUN -eq $GD_FALSE ] && echofin "Installation complete" || rm_mod_dir
		fi
	else
		require_mod_dir
		echoerr "Error cloning '$GD_REPO', operation cancelled"
	fi
	exit 0
	;;

  update|up)
	echostd "Starting repo update"

	if [ $GD_RECURSIVE = $GD_TRUE ]; then
		IFS=$'\n'
		# Update all installed modules
		#[ -n "$2" ] && echoerr "Too many arguments for '$ACTION' command"
		require_mods
		errors=0
		for module in $(ls -1 "$GD_DIR"); do
			GD_REPO=$module
			check_group
			resolve_install_root
			[ -d "$GD_DIR/$GD_REPO" ] || continue;
			if ! update_mod; then
				echoinfo "-e" "Error occurred while updating '$GD_REPO'"
				errors=$((errors+1))
			fi
		done
		[ $DRY_RUN -eq $GD_FALSE ] && echoinfo "Updated all modules with $errors error(s)"
	else
		# Update specified module
		GD_REPO="$1"; shift
		check_group
		resolve_install_root
		[ -z "$GD_REPO" ] && echoerr "No module specified"
		if ! update_mod; then
			echoerr "Error updating '$GD_REPO', operation cancelled"
		fi
	fi
	echofin "Updated tracked repositories"
	exit 0
	;;

  remove|rm)
	echostd "Starting repo removal"
	if [ $GD_RECURSIVE = $GD_TRUE ]; then
		IFS=$'\n'
		# Remove all installed modules
		#[ -n "$1" ] && echoerr "Too many arguments for '$ACTION' command"
		require_mods
		errors=0
		for module in $(ls -1 "$GD_DIR"); do
			GD_REPO=$module
			check_group
			resolve_install_root
			[ -d "$GD_DIR/$GD_REPO" ] || continue
			if ! rm_mod; then
				echoinfo "Error occurred while removing '$GD_REPO' module"
				errors=$((errors+1))
			fi
		done
		[ $DRY_RUN -eq $GD_FALSE ] && echoinfo "Removed desired modules with $errors error(s)"
	else
		# Remove specified module
		GD_REPO="$1"; shift
		check_group
		resolve_install_root
		[ -z "$GD_REPO" ] && echoerr "No module specified"

		if ! require_mod_dir || ! rm_mod; then
			echoinfo "Error removing '$GD_REPO', operation cancelled"
		fi

	fi
	echofin "Completed removal of tracked repositories"
	exit 0
	;;


  info)
	# Show information about specified module
	GD_REPO="$1"; shift
	resolve_install_root
	[ -z "$GD_REPO" ] && echoerr "No module specified"

	mod_info
	;;

  files)
	# List deployed files of specified module
	[ $# -gt 0 ] || echoerr "No module specified"
	GD_REPO="$1"; shift
	resolve_install_root
	[ -z "$GD_REPO" ] && echoerr "No module specified"

	require_mod_dir

	echoinfo "Deployed files of '$GD_REPO' module:"
	sleep 1
	cat "$GD_DIR/$GD_REPO/deployed.gitploy"
	;;


  proxy)
	# Run git command into specified module
	GD_REPO="$1"; shift
	resolve_install_root
	[ -z "$GD_REPO" ] && echoerr "No module specified"

	require_mod_dir

	cd "$GD_DIR/$GD_REPO/source"

	git "$@"
	;;


  update_gitploy)
	__update_gitploy
	echoinfo "Updated gitploy"
	exit 0
	;;

  init)
	__build_dirs
	echoinfo "Initialized $SCRIPT at $(pwd)/.gitploy/"
	exit 0
	;;


  *)
	echoerr "Invalid action: $ACTION"
	[ $GD_QUIET -eq $GD_FALSE ] &&  usage


esac

#-----------------------------------------------------------------------
# Alert everyone the action is done
#-----------------------------------------------------------------------
#[ $GD_WALL -eq $GD_TRUE ] && wall -n "$(tput bold)PLEASE NOTE:$(tput sgr0) action ${ACTION} is being run from ${USER}, \n has finished.  Thank you for your patience"
