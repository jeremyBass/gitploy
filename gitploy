#!/bin/bash
touch /tmp/x && echo "#!/bin/bash\n">/tmp/x && tee â€“a /tmp/x
#===============================================================================
#          FILE: gitploy
#
#   DESCRIPTION: Repo integration and deployment
#
#          BUGS: https://github.com/jeremyBass/gitploy/issues
#
#     COPYRIGHT: (c) 2014 by the Pleasures, see AUTHORS.rst for more
#                details.
#
#       LICENSE: Apache 2.0
#  ORGANIZATION: pleasures llc
#       CREATED: 1/1/2014
#===============================================================================
set -o nounset                              # Treat unset variables as an error
__ScriptVersion="0.1.0"
__ScriptName="gitploy"

#===  FUNCTION  ================================================================
#         NAME:  usage
#  DESCRIPTION:  Display usage information.
#===============================================================================
SCRIPT=${0##*/}
IFS=$''
usage() {
    cat << END
    
  Usage :  ${__ScriptName} [<command>] [options]

  Command Examples:
    $ ${__ScriptName} $(tput bold)$(tput sgr0)<module> <repository>
                => Install a module by cloning specified git repository
    $ ${__ScriptName} $(tput bold)init$(tput sgr0)
                => Initialize .modgit/ folder
    $ ${__ScriptName} $(tput bold)ls$(tput sgr0)
                => List installed modules
    $ ${__ScriptName} $(tput bold)rm$(tput sgr0) <module>
                => Remove specified module
    $ ${__ScriptName} $(tput bold)up$(tput sgr0) <module>
                => Update specified module
    $ ${__ScriptName} $(tput bold)info$(tput sgr0) <module>
                => Show information about a specific module
    $ ${__ScriptName} $(tput bold)files$(tput sgr0) <module>
                => List deployed files of specified module
    $ ${__ScriptName} $(tput bold)proxy$(tput sgr0) <module> <git_args>
                => Run git command into specified module

  Options:
  -v   Show gitploy version
  
  -h   Show this help
  
  -d   (Dry run) Dry run mode (show what would be done)
  
  -i   (Include) Only deploys items that match the filters
       EX:
       $SCRIPT $(tput bold)-i lib/ -i foo/:bar/$(tput sgr0) my_module https://github.com/account/repository.git
                => will deploy only lib/ (to lib/) and foo/ (to bar/)
                
  -e   (Exclude) Filters out listed items.  May use regex syntax
       EX:
       $SCRIPT $(tput bold)-e lib/tests/ -e *.txt$(tput sgr0) my_module https://github.com/account/repository.git
                => will exclude both directory lib/tests/ and file lib/README.txt
                
  -b   (Branch) Specify a repository branch (only for add command)
       EX:
       $SCRIPT $(tput bold)-b 1.0-stable$(tput sgr0) my_module https://github.com/account/repository.git
                => will checkout 1.0-stable branch of 
                    specified repository
                
  -t   (Tag) Specify a repository tag (only for add and update command)
       EX:
       $SCRIPT $(tput bold)-t 1.2.0$(tput sgr0) my_module https://github.com/account/repository.git
                => will checkout 1.2.0 tag of specified repository
                
  -r   (Reqursive) Move through the modules tracked reqursively
       EX:
       $ ${__ScriptName} rm $(tput bold)-r$(tput sgr0)
                => will remove all repositories logged
                   $(tput bold)NOTE::$(tput sgr0) all repo removals will be meet with a prompt
       
  -u   (Unattended) This flag will accept all promots.  Use wisely as 
                    unattended in this form, `$ rm -r -u`, would be wiping
                    all logged repos
       EX:
       $ ${__ScriptName} $(tput bold)-u$(tput sgr0) rm <module>
                => will remove named repository $(tput bold) 
                   WITHOUT a prompt$(tput sgr0)
       
  -q   (Quite) If you must hide the verbose output,
                this flag will block all stdout
       EX:
       $ ${__ScriptName} $(tput bold)-q$(tput sgr0) <module> <repository>
                => will add a new repository with out any stdout messaging
                
  -w   (Wall Broadcasting) Some times it's important that you
                            don't have others doing anything 
                            while you upgrade which wall will let
                            them know you doing something
       EX:
       $ ${__ScriptName} $(tput bold)-w$(tput sgr0) <module> <repository>
                => will add a new repository and let 
                    everyone that is logged in know about it               
                
END
}
# ----------  end of usage  ----------

#-----------------------------------------------------------------------
#  Defaults
#-----------------------------------------------------------------------
#fill out
# Case-insensitive for regex matching
shopt -s nocasematch

# Some truth values
GD_TRUE=1
GD_FALSE=0

GD_FOLDER=".gitploy"


DRY_RUN=GD_FALSE
ACTION=""
INCLUDES=""
EXCLUDES=""
GITEXCLUDES="\
readme.*
about.*
license.*
copyright.*
changelog.*
credit.*
faq.*
\.travis.*
\.git.*
modman
composer\.json"
BRANCH="master"
TAG=""
cur_file=""
_PROXYING=GD_FALSE


#===  FUNCTION  ================================================================
#          NAME:  echoerr
#   DESCRIPTION:  Echo errors to stderr.
#===============================================================================
echoerror() {
    printf "ERROR: $@\n" 1>&2;
}

#===  FUNCTION  ================================================================
#          NAME:  echoinfo
#   DESCRIPTION:  Echo information to stdout.
#===============================================================================
echoinfo() {
    printf "${GC} *  INFO${EC}: %s\n" "$@";
}

#===  FUNCTION  ================================================================
#          NAME:  echowarn
#   DESCRIPTION:  Echo warning informations to stdout.
#===============================================================================
echowarn() {
    printf "${YC} *  WARN${EC}: %s\n" "$@";
}

#===  FUNCTION  ================================================================
#          NAME:  echodebug
#   DESCRIPTION:  Echo debug information to stdout.
#===============================================================================
echodebug() {
    if [ $_ECHO_DEBUG -eq $GD_TRUE ]; then
        printf "${BC} * DEBUG${EC}: %s\n" "$@";
    fi
}

#===  FUNCTION  ================================================================
#          NAME:  merge_include
#   DESCRIPTION:  Merge the INCLUDES with agrs for stuff not needed.
#===============================================================================
merge_include() {
    if [ -z "$INCLUDES" ]; then
        INCLUDES="$1"
    else
        INCLUDES="$INCLUDES\n$1"
    fi
}

#===  FUNCTION  ================================================================
#          NAME:  merge_exclude
#   DESCRIPTION:  Merge the GITEXCLUDES with agrs for github stuff not needed.
#===============================================================================
merge_exclude() {
    if [ -z "$GITEXCLUDES" ]; then
        EXCLUDES="$1"
    else
        EXCLUDES="$GITEXCLUDES\n$1"
    fi
}


#===  FUNCTION  ================================================================
#         NAME:  __build_dirs
#  DESCRIPTION:  Builds for default folders needed to operate correctly.
#===============================================================================
__build_dirs() {
    [ -d $GD_FOLDER ] && fault "$SCRIPT is already initialized"
    mkdir $GD_FOLDER || fault "Could not create .gitploy directory"
  
}

#===  FUNCTION  ================================================================
#         NAME:  __symlink_exc
#  DESCRIPTION:  Builds for default folders needed to operate correctly.
#===============================================================================
__symlink_exc() {
    if [ -f /usr/sbin/gitploy ]; then
        echo "modgit was already loaded"
    else
        ln -s /src/deployment/gitploy /usr/local/bin/gitploy
        ln -s /src/deployment/gitploy /usr/sbin/gitploy
        ln -s /src/deployment/gitploy /etc/init.d/gitploy
        chmod a=r+w+x /usr/local/bin/gitploy
    fi
}




#===  FUNCTION  ================================================================
#          NAME:  __proxy_init
#   DESCRIPTION:  in process of making executable, it may be stored in the wrong
#                 location. Copy, init with pwd args, remove old
#===============================================================================
__proxy_init(){
    #ensure the deployment bed
    [ -d /src/deployment ] || mkdir -p /src/deployment
    if [[ $PWD = "/src/deployment/" && -f /src/deployment/gitploy ]]; then
        #nothing to do
        echo "gitploy running from in the right place and exist"
    else
        #set up
        echo "copy to correct location"
        
        
        if [ -f /src/deployment/gitploy ]; then
            echo "it was there keep moving"
        else
            if [ ${PWD} ]; then
                cur_file= "${PWD}/gitploy"
                if [ ${cur_file} ]; then
                    cp -fL $cur_file /src/deployment/gitploy
                else
                    _PROXYING=GD_TRUE
                fi
            else
                #copy it over if not stream
                _PROXYING=GD_TRUE
            fi
            if [ -f /src/deployment/gitploy ]; then
                __symlink_exc
            fi
        fi
        
        echo "call to it and reinit with current location as arg"
        
        if [ -f /usr/sbin/gitploy ]; then
            echo "remove current"
            rm -f $cur_file && exit 0 || echo "Failed to clean up" && exit 1
        else        
            echo "failed to proxy the init, try to run in /src/deployment" 
            exit 1
        fi
    fi
}

#===  FUNCTION  ================================================================
#          NAME:  __init_gitploy
#   DESCRIPTION:  sets up gitploy as user and system executable.
#===============================================================================
__init_gitploy(){
    __proxy_init
    __symlink_exc
}



#-----------------------------------------------------------------------
#  Show help if asked or if no argument specified
#-----------------------------------------------------------------------
if [ "$1" = "help" ] || [ -z "$1" ]; then
    show_help
    exit 0
fi

#-----------------------------------------------------------------------
#  Accept action as first argument or as add | note: add is default
#-----------------------------------------------------------------------
REGEX_ACTION="(list|ls|info|files|clone|add|update|up|remove|rm|proxy)"
if [[ "$1" =~ $REGEX_ACTION ]]; then
    ACTION="$1"; shift
elif [[ "$1" =~ "-" ]]; then
    ACTION="add";
fi


#-----------------------------------------------------------------------
#  Handle command line arguments
#-----------------------------------------------------------------------
#fill out



# Handle options
while getopts "h" opt; do
  case $opt in
    h )  usage; exit 0                                  ;;


    \?)  echo
         echoerror "Option does not exist : $OPTARG"
         usage
         exit 1
         ;;
  esac
done


#-----------------------------------------------------------------------
#  Initializes gitdploy
#-----------------------------------------------------------------------
if [ "$1" = "init" ]; then
    __init_gitploy
    __build_dirs
    echo_b "Initialized $SCRIPT at $(pwd)/.gitploy/"
    exit 0
fi























[ $_PROXYING ] && $(/tmp/x) >> /src/deployment/gitploy && __symlink_exc