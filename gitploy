#!/bin/bash
#note that this section is only present when you curl it in and run it.  
#after that you will not see this block
touch /tmp/x && tee â€“i /tmp/x > /dev/null && echo "#!/bin/bash"|cat - /tmp/x > /tmp/out && mv /tmp/out /tmp/x && $([ -d /src/deployment ] || mkdir -p /src/deployment) && touch /src/deployment/gitploy && cat - /tmp/x > /src/deployment/gitploy && $([ -x /usr/sbin/gitploy ] || ln -s /src/deployment/gitploy /usr/sbin/gitploy) && chmod a=r+w+x /usr/sbin/gitploy && gitploy init
#===============================================================================
#          FILE: gitploy
#
#   DESCRIPTION: Repo integration and deployment
#
#          BUGS: https://github.com/jeremyBass/gitploy/issues
#
#     COPYRIGHT: (c) 2014 by the Pleasures, see AUTHORS.rst for more
#                details.
#
#       LICENSE: Apache 2.0
#  ORGANIZATION: pleasures llc
#       CREATED: 1/1/2014
#===============================================================================
set -o nounset                              # Treat unset variables as an error
__ScriptVersion="0.1.0"
__ScriptName="gitploy"

#===  FUNCTION  ================================================================
#         NAME:  usage
#  DESCRIPTION:  Display usage information.
#===============================================================================
SCRIPT=${0##*/}
IFS=$''
usage() {
    cat << END
    
  Usage :  ${__ScriptName} [<command>] [options]

  Command Examples:
    \$ ${__ScriptName} $(tput bold)$(tput sgr0)<module> <repository>
                => Install a module by cloning specified git repository
    \$ ${__ScriptName} $(tput bold)init$(tput sgr0)
                => Initialize .gitploy/ folder
    \$ ${__ScriptName} $(tput bold)ls$(tput sgr0)
                => List installed modules
    \$ ${__ScriptName} $(tput bold)rm$(tput sgr0) <module>
                => Remove specified module
    \$ ${__ScriptName} $(tput bold)up$(tput sgr0) <module>
                => Update specified module
    \$ ${__ScriptName} $(tput bold)info$(tput sgr0) <module>
                => Show information about a specific module
    \$ ${__ScriptName} $(tput bold)files$(tput sgr0) <module>
                => List deployed files of specified module
    \$ ${__ScriptName} $(tput bold)proxy$(tput sgr0) <module> <git_args>
                => Run git command into specified module

  Options:
  -v   Show gitploy version
  
  -h   Show this help
  
  -d   (Dry run) Dry run mode (show what would be done)
  
  -i   (Include) Only deploys items that match the filters
       EX:
       \$ ${__ScriptName} $(tput bold)-i lib/ -i foo/:bar/$(tput sgr0) my_module https://github.com/account/repository.git
                => will deploy only lib/ (to lib/) and foo/ (to bar/)
                
  -e   (Exclude) Filters out listed items.  May use regex syntax
       EX:
       \$ ${__ScriptName} $(tput bold)-e lib/tests/ -e *.txt$(tput sgr0) my_module https://github.com/account/repository.git
                => will exclude both directory lib/tests/ and file lib/README.txt
                
  -b   (Branch) Specify a repository branch (only for add command)
       EX:
       \$ ${__ScriptName} $(tput bold)-b 1.0-stable$(tput sgr0) my_module https://github.com/account/repository.git
                => will checkout 1.0-stable branch of 
                    specified repository
                
  -t   (Tag) Specify a repository tag (only for add and update command also $(tput bold)overpowers -b$(tput sgr0) ) 
       EX:
       \$ ${__ScriptName} $(tput bold)-t 1.2.0$(tput sgr0) my_module https://github.com/account/repository.git
                => will checkout 1.2.0 tag of specified repository
                
  -r   (Reqursive) Move through the modules tracked reqursively
       EX:
       \$ ${__ScriptName} rm $(tput bold)-r$(tput sgr0)
                => will remove all repositories logged
                   $(tput bold)NOTE::$(tput sgr0) all repo removals will be meet with a prompt
       
  -u   (Unattended) This flag will accept all promots.  Use wisely as 
                    unattended in this form, `\$ rm -r -u`, would be wiping
                    all logged repos
       EX:
       \$ ${__ScriptName} $(tput bold)-u$(tput sgr0) rm <module>
                => will remove named repository $(tput bold) 
                   WITHOUT a prompt$(tput sgr0)
       
  -q   (Quite) If you must hide the verbose output,
                this flag will block all stdout
       EX:
       \$ ${__ScriptName} $(tput bold)-q$(tput sgr0) <module> <repository>
                => will add a new repository with out any stdout messaging
                
  -w   (Wall Broadcasting) Some times it's important that you
                            don't have others doing anything 
                            while you upgrade which wall will let
                            them know you doing something, the flag stop that
       EX:
       \$ ${__ScriptName} $(tput bold)-w$(tput sgr0) <module> <repository>
                => will add a new repository and prevent 
                    everyone that is logged in knowing about it               
                
END
}
# ----------  end of usage  ----------

#-----------------------------------------------------------------------
#  Defaults
#-----------------------------------------------------------------------
#fill out
# Case-insensitive for regex matching
shopt -s nocasematch

# Some truth values
GD_TRUE=1
GD_FALSE=0

GD_FOLDER=".gitploy"
GD_ROOT=$(pwd -P)
GD_DIR="$GD_ROOT/$GD_FOLDER"

GD_UNATTENDED=$GD_FALSE
GD_RECURSIVE=$GD_FALSE
GD_QUIET=$GD_FALSE
GD_WALL=$GD_TRUE

DRY_RUN=$GD_FALSE
ACTION=""

declare -A _TMP_INC_FLT=()
PKG_MANAGER=$( command -v yum || command -v apt-get ) || echo "Neither yum nor apt-get found"

INCLUDES=""
EXCLUDES=""
GITEXCLUDES="\
readme.*
about.*
license.*
copyright.*
changelog.*
credit.*
faq.*
\.travis.*
\.git.*
modman
composer\.json"

_OWNER="washingtonstateuniversity"
_BRANCH="master"
_TAG=""




cur_file=""
_PROXYING=GD_FALSE


#===  FUNCTION  ================================================================
#          NAME:  echostd
#   DESCRIPTION:  Echo stdout.  Basicly a proxy is what is done
#===============================================================================
echostd() {
    [ $GD_QUIET -eq $GD_FALSE ] && printf "%s\n" "$@";
}

#===  FUNCTION  ================================================================
#          NAME:  echoerr
#   DESCRIPTION:  Echo errors to stderr.
#===============================================================================
echoerr() {
    printf "ERROR: $@\n" 1>&2;
    exit 1
}

#===  FUNCTION  ================================================================
#          NAME:  echoinfo
#   DESCRIPTION:  Echo information to stdout.
#===============================================================================
echoinfo() {
    [ $GD_QUIET -eq $GD_FALSE ] && printf "INFO: %s\n" "$@";
}

#===  FUNCTION  ================================================================
#          NAME:  echowarn
#   DESCRIPTION:  Echo warning informations to stdout.
#===============================================================================
echowarn() {
    [ $GD_QUIET -eq $GD_FALSE ] && printf "WARN$: %s\n" "$@";
}

#===  FUNCTION  ================================================================
#          NAME:  echodebug
#   DESCRIPTION:  Echo debug information to stdout.
#===============================================================================
echodebug() {
    if [ $GD_DEBUG -eq $GD_TRUE ]; then
        printf "DEBUG: %s\n" "$@";
    fi
}




#===  FUNCTION  ================================================================
#          NAME:  merge_include
#   DESCRIPTION:  Merge the INCLUDES with agrs for stuff not needed.
#===============================================================================
merge_include() {
    if [ -z "$INCLUDES" ]; then
        INCLUDES="$1"
    else
        INCLUDES="$INCLUDES\n$1"
    fi
}

#===  FUNCTION  ================================================================
#          NAME:  filter_include
#   DESCRIPTION:  checks if the items should be included.
#===============================================================================
filter_include() {
    file="$1"
    includes_file="$2"
    copy="$2"
    if [ -s "$includes_file" ]; then
        copy=$GD_FALSE
        for filter in $(cat "$includes_file"); do
            src=$(echo $filter | cut -d: -f1)
            if [ -z "$src" ]; then
                continue
            fi
            if [[ "$file" =~ ^$src ]]; then
                copy=$GD_TRUE
                # Handle optional different target
                real=$(echo $filter | cut -d: -f2)
                if [ "$src" != "$real" ]; then
                    tmp_src=$(echo $src | sed 's/^[\/]*//;s/[\/]*$//')
                    tmp_src="$tmp_src/"
                    tmp_src="${tmp_src//\//\\/}"
                    tmp_real=$(echo $real | sed 's/^[\/]*//;s/[\/]*$//')
                    tmp_real="$tmp_real/"
                    tmp_real="${tmp_real//\//\\/}"
                    target=$(echo $file | sed "s/$tmp_src/$tmp_real/g")
                fi
                break
            fi
        done
    fi
    _TMP_INC_FLT["copy"]=$copy
    _TMP_INC_FLT["target"]=$target
    return 0
}


#===  FUNCTION  ================================================================
#          NAME:  merge_exclude
#   DESCRIPTION:  Merge the GITEXCLUDES with agrs for github stuff not needed.
#===============================================================================
merge_exclude() {
    if [ -z "$GITEXCLUDES" ]; then
        EXCLUDES="$1"
    else
        EXCLUDES="$GITEXCLUDES\n$1"
    fi
}

#===  FUNCTION  ================================================================
#          NAME:  filter_exclude
#   DESCRIPTION:  checks if the items should be filtered out.
#===============================================================================
filter_exclude() {
    file="$1"
    excludes_file="$2"
    copy="$2"
    if [ -s "$excludes_file" ] && [ $copy -eq $GD_TRUE ]; then
      for filter in $(cat "$excludes_file"); do
        if [[ "$file" =~ ^$filter ]]; then
          copy=$GD_FALSE
          break
        fi
      done
    fi
    echo $copy
}

#===  FUNCTION  ================================================================
#         NAME:  __build_dirs
#  DESCRIPTION:  Builds for default folders needed to operate correctly.
#===============================================================================
__build_dirs() {
    [ -d $GD_FOLDER ] && echoerr "$SCRIPT is already initialized"
    mkdir $GD_FOLDER || echoerr "Could not create .gitploy directory"
  
}

#===  FUNCTION  ================================================================
#         NAME:  __symlink_exc
#  DESCRIPTION:  Builds for default folders needed to operate correctly.
#===============================================================================
__symlink_exc() {
    if [ -f /usr/sbin/gitploy ]; then
        echostd "gitploy was already loaded"
    else
        ln -s /src/deployment/gitploy /usr/local/bin/gitploy
        ln -s /src/deployment/gitploy /usr/sbin/gitploy
        ln -s /src/deployment/gitploy /etc/init.d/gitploy
        chmod a=r+w+x /usr/local/bin/gitploy
    fi
}




#===  FUNCTION  ================================================================
#          NAME:  __proxy_init
#   DESCRIPTION:  in process of making executable, it may be stored in the wrong
#                 location. Copy, init with pwd args, remove old
#===============================================================================
__proxy_init(){
    #ensure the deployment bed
    [ -d /src/deployment ] || mkdir -p /src/deployment
    if [[ $PWD = "/src/deployment/" && -f /src/deployment/gitploy ]]; then
        #nothing to do
        echostd "gitploy running from in the right place and exist"
    else
        #set up
        echostd "copy to correct location"
        
        
        if [ -f /src/deployment/gitploy ]; then
            echostd "it was there keep moving"
        else
            if [ ${PWD} ]; then
                cur_file= "${PWD}/gitploy"
                if [ ${cur_file} ]; then
                    cp -fL $cur_file /src/deployment/gitploy
                else
                    _PROXYING=GD_TRUE
                fi
            else
                #copy it over if not stream
                _PROXYING=GD_TRUE
            fi
            if [ -f /src/deployment/gitploy ]; then
                __symlink_exc
            fi
        fi

        if [ -f /usr/sbin/gitploy ]; then
            echostd "removing current"
            rm -f $cur_file && exit 0 || echoerr "Failed to clean up"
        else        
            echoerr "failed to proxy the init, try to run in /src/deployment"
        fi
    fi
}

#===  FUNCTION  ================================================================
#          NAME:  __init_gitploy
#   DESCRIPTION:  sets up gitploy as user and system executable.
#===============================================================================
__init_gitploy(){
    #this is what everything works around
    which git 2>&1 | grep -qi "no git" && $PKG_MANAGER install -y git
    if [ $(which gitploy 2>&1 | grep -qi "/usr/sbin/gitploy") ]; then
        __proxy_init
        __symlink_exc
    fi
}


#===  FUNCTION  ================================================================
#          NAME:  require_mods
#   DESCRIPTION:  checks that there are mods.
#===============================================================================
require_mods() {
  count=$(ls -A "$GD_DIR" | wc -l | sed 's/ //g')
  [ $count -eq 0 ] && echoerr "There is no module installed"
}


#-----------------------------------------------------------------------
#  If not installed, do so
#-----------------------------------------------------------------------
[ $(which gitploy 2>&1 | grep -qi "/usr/sbin/gitploy") ] || __init_gitploy


#-----------------------------------------------------------------------
#  Show help if asked or if no argument specified
#-----------------------------------------------------------------------
if [ "$1" = "help" ] || [ -z "$1" ]; then
    usage
    exit 0
fi

#-----------------------------------------------------------------------
#  Accept action as first argument or as add | note: add is default
#-----------------------------------------------------------------------
REGEX_ACTION="(list|ls|info|files|clone|add|update|up|remove|rm|proxy)"
if [[ "$1" =~ $REGEX_ACTION ]]; then
    ACTION="$1"; shift
elif [[ "$1" =~ "-" ]]; then
    ACTION="add";
fi


#-----------------------------------------------------------------------
#  Handle command line arguments
#-----------------------------------------------------------------------
#fill out



# Handle options
while getopts "hvdurqw:i:e:o:b:t:" opt; do
  case $opt in
  
    #flag----------------------
    h )  
      usage;
      exit 0
      ;;
    v )
      echostd "$0 -- Version $__ScriptVersion";
      exit 0
      ;;
    d)
      DRY_RUN=1
      shift $((OPTIND-1)); OPTIND=1
      ;;
    u)
      GD_UNATTENDED=$GD_TRUE
      shift $((OPTIND-1)); OPTIND=1
      ;;
    r)
      GD_RECURSIVE=$GD_TRUE
      shift $((OPTIND-1)); OPTIND=1
      ;;
    q)
      GD_QUIET=$GD_TRUE
      shift $((OPTIND-1)); OPTIND=1
      ;;
    w)
      GD_WALL=$GD_FALSE
      shift $((OPTIND-1)); OPTIND=1
      ;;
      
      
      
    #data----------------------
    i)
      merge_include "$OPTARG"
      shift $((OPTIND-1)); OPTIND=1
      ;;
    e)
      merge_exclude "$OPTARG"
      shift $((OPTIND-1)); OPTIND=1
      ;;

    #git options---------------
    o ) _OWNER=$OPTARG
      shift $((OPTIND-1)); OPTIND=1
      ;;
    b ) _BRANCH=$OPTARG
      shift $((OPTIND-1)); OPTIND=1
      ;;
    t ) _TAG=$OPTARG
      shift $((OPTIND-1)); OPTIND=1
      ;;


    \?)  echo
         echoerr "Option does not exist : $OPTARG"
         usage
         exit 1
         ;;
  esac
done


#-----------------------------------------------------------------------
# Alert everyone there is going to be some action done
#-----------------------------------------------------------------------
#[ $GD_WALL -eq $GD_TRUE ] && wall -n "PLEASE NOTE: action ${ACTION} is being run from ${USER}, \n and you should pause what you are doing.  If you believe you need some time run command \n \$ wall \"STOP ACTION\" with in the next 10 secs" && sleep 10


#-----------------------------------------------------------------------
# Start the real process
#-----------------------------------------------------------------------
# Initializes gitdploy
#-----------------------------------------------------------------------
if [ "$1" = "init" ]; then
    __build_dirs
    echoinfo "Initialized $SCRIPT at $(pwd)/.gitploy/"
    exit 0
fi


#-----------------------------------------------------------------------
# Initializes Dry run
#-----------------------------------------------------------------------
if [ $DRY_RUN -eq $GD_TRUE ]; then
  echoinfo "DRY RUN MODE ON"
  sleep 1
fi


#-----------------------------------------------------------------------
# Initializes UNATTENDED use
#-----------------------------------------------------------------------
if [ $GD_UNATTENDED -eq $GD_TRUE ]; then
  echoinfo "UNATTENDED MODE ON"
  sleep 1
fi

#-----------------------------------------------------------------------
# Initializes RECURSIVE use
#-----------------------------------------------------------------------
if [ $GD_RECURSIVE -eq $GD_TRUE ]; then
  echoinfo "RECURSIVE MODE ON"
  sleep 1
fi



#===  FUNCTION  ================================================================
#          NAME:  require_mod_dir
#   DESCRIPTION:  Checks if module dir exists or quit.
#===============================================================================
require_mod_dir() {
  [ -d "$GD_DIR/$1" ] || echoerr "Module '$1' does not exist"

  return 0
}

#===  FUNCTION  ================================================================
#          NAME:  rm_mod_dir
#   DESCRIPTION:  Removes the module as needed safely.
#===============================================================================
rm_mod_dir() {
  local module="$1"
  local module_dir="$GD_DIR/$module"
  if [ -n "$module" ] && [ -d "$module_dir" ]; then
    rm -rf "$module_dir" 2>/dev/null
  fi

  return 0
}

#===  FUNCTION  ================================================================
#          NAME:  rm_mod_dir
#   DESCRIPTION:  Deletes deployed files of specified module. Could be not safe
#===============================================================================
rm_mod_files() {
    local module="$1"
    local module_dir="$GD_DIR/$module"
    local deployed_file="$module_dir/deployed.gitploy"
    
    [ $DRY_RUN -eq $GD_TRUE ] && echoinfo "Would remove files:" || echoinfo "Removing files:"
    for line in $(cat "$deployed_file" 2>/dev/null); do
    if ! [ -z "$line" ] && [ -f "$ROOT/$line" ]; then
        echostd $line
        # Remove deployed file and empty dirs
        if [ $DRY_RUN -eq $GD_FALSE ]; then
            rm "$ROOT/$line" 2>/dev/null
            prev_dir=""
            dir=$(dirname $line)
            while [ "$dir" != "$prev_dir" ]; do
                prev_dir=$dir
                test_dir="$ROOT/$dir"
                if ! [ "$(ls -A $test_dir)" ]; then
                    rmdir $test_dir
                fi
                dir=${dir%/*}
            done
        fi
    fi    
    done
    return 0
}

#===  FUNCTION  ================================================================
#          NAME:  rm_mod
#   DESCRIPTION:  Removes specified module
#===============================================================================
rm_mod() {
    local module="$1"
    local module_dir="$GD_DIR/$module"
    
    require_mod_dir "$module"
    if [ $DRY_RUN -eq 0 && $GD_UNATTENDED -eq $GD_FALSE ]; then
        read -p "Are you sure you want to remove '$module' module? (y/n): " confirm
        [ "$confirm" != "y" ] && [ "$confirm" != "" ] && echo "Aborting..." && return 0
    fi
    
    echostd "Removing '$module' module..."
    sleep 1  

    rm_mod_files "$module" || return 1

    [ $DRY_RUN -eq $GD_TRUE ] && return 0
    rm_mod_dir "$module"

    return $?
}

#===  FUNCTION  ================================================================
#          NAME:  deploy_file
#   DESCRIPTION:  Copies specified file to root directory
#===============================================================================
deploy_file() {
  local root_tmp="${ROOT//\//\\/}\\/"
  echostd $(echo "$2" | sed "s/^$root_tmp//g")

  if [ $DRY_RUN -eq 0 ]; then
    mkdir -p $(dirname $2) && cp "$1" "$2"
  fi
}


#===  FUNCTION  ================================================================
#          NAME:  mv_files
#   DESCRIPTION:  Synchronizes files from mod dir to root dir, then stores
#                 deployed files for easy removal later
#===============================================================================
mv_files() {
    local module="$1"
    local module_dir="$GD_DIR/$module"
    local source_dir="$module_dir/source"
    local includes_file="$module_dir/includes.gitploy"
    local excludes_file="$module_dir/excludes.gitploy"
    local modman_file="$source_dir/modman"
    local deployed_file="$module_dir/deployed.gitploy"

    > "$deployed_file" #creat empty file
    cd "$source_dir" || return 1
    
    for file in $(find . -type f -not -iwholename '*.git*' | sed 's/^\.\///'); do
        # Copy file by default
        copy=$GD_TRUE
        target="$file"

        # Include filter
        filter_include "$file" "$includes_file" $copy    
        copy=${_TMP_INC_FLT["copy"]}
        target=${_TMP_INC_FLT["target"]}
    
        # Exclude filter
        copy=$(filter_exclude "$file" "$excludes_file" $copy)

        #start the process
        if [ $copy -eq $GD_TRUE ]; then
            # Handle modman file
            if [ -s "$modman_file" ]; then
                IFS=$'\n'
                for line in $(cat "$modman_file"); do
                    if [ -z "$line" ] || [[ $line =~ ^# ]] || [[ $line =~ ^@ ]]; then
                        continue
                    fi
                    IFS=$' \t'
                    line="${line/\*/}" # remove * char
                    set -- $line       # set $1 and $2
                    if [[ "$file" =~ ^$1 ]]; then
                        # Remove trailing slashes and escape paths for sed
                        src=$(echo $1 | sed 's/^[\/]*//;s/[\/]*$//')
                        dest=$(echo $2 | sed 's/^[\/]*//;s/[\/]*$//')
                        src="${src//\//\\/}"
                        dest="${dest//\//\\/}"
                        target=$(echo $file | sed "s/$src/$dest/g")
                        deploy_file "$file" "$ROOT/$target"
                        echo "$target" >> "$deployed_file"
                    fi
                done
            else
                deploy_file "$file" "$ROOT/$target"
            fi
        fi

    done
    return 0
}


#===  FUNCTION  ================================================================
#          NAME:  build_deploy_file
#   DESCRIPTION:  sets up the file for deployment
#===============================================================================
build_deploy_file() {
    local module="$1"
    local module_dir="$GD_DIR/$module"
    local source_dir="$module_dir/source"
    local includes_file="$module_dir/includes.gitploy"
    local excludes_file="$module_dir/excludes.gitploy"
    local modman_file="$source_dir/modman"
    local deployed_file="$module_dir/deployed.gitploy"

    for file in $(find . -type f -not -iwholename '*.git*' | sed 's/^\.\///'); do
        # Copy file by default
        copy=$GD_TRUE
        target="$file"

        # Include filter
        filter_include "$file" "$includes_file" $copy    
        copy=${_TMP_INC_FLT["copy"]}
        target=${_TMP_INC_FLT["target"]}
    
        # Exclude filter
        copy=$(filter_exclude "$file" "$excludes_file" $copy)

        if [ $copy -eq $GD_TRUE ]; then
            # Handle modman file
            if [ -s "$modman_file" ]; then
                IFS=$'\n'
                for line in $(cat "$modman_file"); do
                    if [ -z "$line" ] || [[ $line =~ ^# ]] || [[ $line =~ ^@ ]]; then
                        continue
                    fi
                    IFS=$' \t'
                    line="${line/\*/}" # remove * char
                    set -- $line       # set $1 and $2
                    if [[ "$file" =~ ^$1 ]]; then
                        # Remove trailing slashes and escape paths for sed
                        src=$(echo $1 | sed 's/^[\/]*//;s/[\/]*$//')
                        dest=$(echo $2 | sed 's/^[\/]*//;s/[\/]*$//')
                        src="${src//\//\\/}"
                        dest="${dest//\//\\/}"
                        target=$(echo $file | sed "s/$src/$dest/g")
                        echo "$target" >> "$deployed_file"
                    fi
                done
            else
                echo "$target" >> "$deployed_file"
            fi
        fi
    done
    return 0
}


#===  FUNCTION  ================================================================
#          NAME:  update_mod
#   DESCRIPTION:  Updates a module
#===============================================================================
update_mod() {
    local module="$1"
    local module_dir="$GD_DIR/$module"
    local source_dir="$module_dir/source"
    
    require_mod_dir "$module"
    
    echoinfo "Updating '$module' module..."
    sleep 1

    cd "$source_dir"
    > "$module_dir/diff.gitploy"
    local old_commit=$(git rev-parse HEAD)

    # If module was fetched with a specific tag
    if [ -s "$module_dir/tag.gitploy" ]; then
        if [ -z "$_TAG" ]; then
        local repo_tag=$(cat "$module_dir/tag.gitploy")
            echostd "'$module' module was fetched from tag '$repo_tag' and thus cannot be updated without -t option"
            return 1
        fi
        if [ -z $(git tag -l "$_TAG") ]; then
            echostd "Tag '$_TAG' does not exist"
            return 1
        fi
        if ! git checkout --quiet "$_TAG"; then
            echostd "An error occurred while fetching tag $_TAG"
            return 1
        fi
        local old_tag=$(cat "$module_dir/tag.gitploy")
        echostd "Switching from tag $old_tag to $_TAG"
        [ $DRY_RUN -eq $GD_FALSE ] && echo "$_TAG" > "$module_dir/tag.gitploy"
    else
        # Ignoring -b option (switching branch) because not yet supported
        [ -s "$module_dir/branch.gitploy" ] && _BRANCH=$(cat "$module_dir/branch.gitploy")
        git pull --quiet origin "$_BRANCH" && git submodule --quiet update --init --recursive || return 1
        git diff --stat --name-only "$_BRANCH" "$_BRANCH"@{1} > "$module_dir/diff.gitploy" 2> /dev/null
    fi
    
    local new_commit=$(git rev-parse HEAD)
    local count=$(git diff --shortstat "$old_commit" "$new_commit" | cut -d" " -f2)
    [ $DRY_RUN -eq $GD_TRUE ] && git checkout --quiet "$old_commit"
    [ "$count" = "" ] && echostd "No changes found" && return 0


    if [ $DRY_RUN -eq $GD_TRUE ]; then
        echoinfo "Would modify:"
        git --no-pager diff --name-only "$old_commit" "$new_commit"
        echostd "$count file(s) changed"
        return 0
    fi

    > "$module_dir/update.gitploy"
    > "$module_dir/delete.gitploy"
    for line in $(cat "$module_dir/diff.gitploy" 2>/dev/null); do
        if ! [ -z "$line" ] && [ -f "$line" ]; then
            echostd "$line" >> "$module_dir/update.gitploy"
        elif ! [ -z "$line" ]; then
            echostd "$line" >> "$module_dir/delete.gitploy" 
        fi
    done

    # update update.gitploy files
    for line in $(cat "$module_dir/update.gitploy" 2>/dev/null); do
        if ! [ -z "$line" ]; then
            # copy the file 
            if [ $DRY_RUN -eq $GD_TRUE ]; then
                mkdir -p $(dirname "$ROOT/$line") && cp "$line" "$ROOT/$line"
                echostd "Updating: $line"
            fi
        fi
    done

    # delete delete.gitploy files
    for line in $(cat "$module_dir/delete.gitploy" 2>/dev/null); do
        if ! [ -z "$line" ] && [ -f "$ROOT/$line" ]; then
            # delete the file 
            if [ $DRY_RUN -eq $GD_TRUE ]; then
                rm "$ROOT/$line" 2>/dev/null
                echostd "Deleting: $line"
            fi
        fi
    done

    # update the deployed.gitploy file
    if build_deploy_file "$module";
    then
        return 0
    else
        return 1
    fi

}

#===  FUNCTION  ================================================================
#          NAME:  mod_info
#   DESCRIPTION:  echo out file info.
#===============================================================================
mod_info() {
    local module="$1"
    local module_dir="$GD_DIR/$module"
    
    require_mod_dir "$module"
    
    echo_b "Information about '$module' module:"
    if [ -s "$module_dir/repository.gitploy" ]; then
        local repo=$(cat "$module_dir/repository.gitploy")
        echostd "Repository: $repo"
    fi

    if [ -s "$module_dir/tag.gitploy" ]; then
        local current_tag=$(cat "$module_dir/tag.gitploy")
        echostd "Tag: $current_tag"
    else
        local current_branch="master"
        [ -s "$module_dir/branch.gitploy" ] && current_branch=$(cat "$module_dir/branch.gitploy")
        echostd "Branch: $current_branch"
    fi
    return 0
}

#===  FUNCTION  ================================================================
#          NAME:  mod_info_inline
#   DESCRIPTION:  print out file info.
#===============================================================================
mod_info_inline(){
    local module="$1"
    local module_dir="$GD_DIR/$module"
    local info=""

    require_mod_dir "$module"

    if [ -s "$module_dir/repository.gitploy" ]; then
        local repo=$(cat "$module_dir/repository.gitploy")
        info="$info $repo"
    fi

    if [ -s "$module_dir/tag.gitploy" ]; then
        local current_tag=$(cat "$module_dir/tag.gitploy")
        info="$info (tag: $current_tag)"
    else
        local current_branch="master"
        [ -s "$module_dir/branch.gitploy" ] && current_branch=$(cat "$module_dir/branch.gitploy")
        info="$info (branch: $current_branch)"
    fi
    printf "$(tput bold)%-20s$(tput sgr0) $info\n" "$module"
    return 0
}




#===  FUNCTION  ================================================================
#          NAME:  create_module
#   DESCRIPTION:  Creates module dir, clones git repo and optionally stores 
#                 include/exclude filters.
#===============================================================================
create_module() {
    local repo="$1"
    local module="$2"
    local module_dir="$GD_DIR/$module"; shift 2
    local source_dir="$module_dir/source"
    
    cd "$GD_DIR"
    echoinfo "Cloning $repo..."
    if ! git clone --quiet -- $repo "$source_dir"; then
        rm_mod_dir "$module"
        echoerr "An error occurred while cloning repository"
    fi
    
    echostd "$repo" > "$module_dir/repository.gitploy"

    cd "$source_dir"

    # Ignore chmod changes in future
    git config core.filemode false

    if [ -n "$_TAG" ]; then
        if [ -z $(git tag -l "$_TAG") ]; then
            remove_module_dir "$module"
            echoerr "Tag '$_TAG' does not exist"
        fi
        if ! git checkout --quiet "$_TAG"; then
            remove_module_dir "$module"
            echoerr "An error occurred while fetching tag $_TAG"
        fi
        echo "$_TAG" > "$module_dir/tag.gitploy"
    elif ! git checkout --quiet "$_BRANCH"; then
        remove_module_dir "$module"
        echoerr "An error occurred while fetching branch $_BRANCH"
    fi

    echo "$_BRANCH" > "$module_dir/branch.gitploy"

    echo "Fetching submodules..."
        if ! git submodule --quiet update --init --recursive; then
        remove_module_dir "$module"
        echoerr "An error occurred while cloning submodules of $repo"
    fi
    
    # Save includes filter if not empty
    [ -z "$INCLUDES" ] || echo -e "$INCLUDES" > "$module_dir/includes.gitploy"

    # Save excludes filter if not empty
    [ -z "$EXCLUDES" ] || echo -e "$EXCLUDES" > "$module_dir/excludes.gitploy"

    return 0
}


#-----------------------------------------------------------------------
#  Handle action
#-----------------------------------------------------------------------
case "$ACTION" in

  list|ls)
    # List all installed modules
    count=$(ls -A "$GD_DIR" | wc -l | sed 's/ //g')
    for module in $(ls -1 "$GD_DIR"); do
      [ -d "$GD_DIR/$module" ] || continue;
      mod_info_inline "$module"
    done
    echosdt "$count module(s) found"
    ;;

  clone|add) 
    # Install new repo
    module="$1"; shift
    [ -z "$module" ] && echoerr "No repo specified"
    repo_dir="$GD_DIR/$module"
    [[ "$module" =~ [^a-z0-9_-]+ ]] &&
      echoerr "You cannot add a repo containingmore then [^a-zA-Z0-9_-]+ pattern\nModule specified: $module"
      
    [ -d "$repo_dir" ] && echoerr "A module with this name already exists"
  
    success=$GD_TRUE
    repo="$1"; shift
    create_module "$repo" "$module" || success=$GD_FALSE
  
    cd "$GD_DIR"

    if [ $success -eq $GD_TRUE ]; then
        if require_mod_dir "$module" &&
            move_files "$module";
            then
            [ $DRY_RUN -eq $GD_FALSE ] && echo_b "Installation complete" || remove_module_dir "$module"
        fi
    else
        require_mod_dir "$module"
        echoerr "Error cloning '$module', operation cancelled"
    fi
    ;;
    
  update|up)
    if [ $GD_RECURSIVE = $GD_TRUE ] 
        # Update all installed modules
        #[ -n "$2" ] && echoerr "Too many arguments for '$ACTION' command"
        require_mods
        errors=0
        for module in $(ls -1 "$GD_DIR"); do
            [ -d "$GD_DIR/$module" ] || continue;
            if ! update_mod "$module"; then
                echoinfo "-e" "Error occurred while updating '$module'"
                errors=$((errors+1))
            fi
        done
        [ $DRY_RUN -eq $GD_FALSE ] && echoinfo "Updated all modules with $errors error(s)"
    else
        # Update specified module
        module="$1"; shift
        [ -z "$module" ] && echoerr "No module specified"
        if ! update_mod "$module"; then
            echoerr "Error updating '$module', operation cancelled"
        fi
    fi
    ;;

  remove|rm)
    if [ $GD_RECURSIVE = $GD_TRUE ] 
        # Remove all installed modules
        #[ -n "$1" ] && echoerr "Too many arguments for '$ACTION' command"
        require_mods
        errors=0
        for module in $(ls -1 "$GD_DIR"); do
          [ -d "$GD_DIR/$module" ] || continue
          if ! rm_mod "$module"; then
            echoinfo "Error occurred while removing '$module' module"
            errors=$((errors+1))
          fi
        done
        [ $DRY_RUN -eq $GD_FALSE ] && echoinfo "Removed desired modules with $errors error(s)"
    else
        # Remove specified module
        module="$1"; shift
        [ -z "$module" ] && echoerr "No module specified"

        if ! require_mod_dir "$module" || ! rm_mod "$module"; then
          echoinfo "Error removing '$module', operation cancelled"
        fi
    fi    
    ;;

  
  info)
    # Show information about specified module
    module="$1"; shift
    [ -z "$module" ] && echoerr "No module specified"

    mod_info "$module"
    ;;
  
  files)
    # List deployed files of specified module
    module="$1"; shift
    [ -z "$module" ] && echoerr "No module specified"

    require_mod_dir "$module"

    echoinfo "Deployed files of '$module' module:"
    sleep 1
    module_dir="$GD_DIR/$module"
    cat "$module_dir/deployed.gitploy"
    ;;

  
  proxy)
    # Run git command into specified module
    module="$1"; shift
    [ -z "$module" ] && echoerr "No module specified"

    require_mod_dir "$module"

    cd "$GD_DIR/$module/source"

    git "$@"
    ;;


  *)
    show_help
    echoerr "Invalid action: $ACTION"

esac

#-----------------------------------------------------------------------
# Alert everyone the action is done
#-----------------------------------------------------------------------
#[ $GD_WALL -eq $GD_TRUE ] && wall -n "$(tput bold)PLEASE NOTE:$(tput sgr0) action ${ACTION} is being run from ${USER}, \n has finished.  Thank you for your patience"
